# Code generated by "wunderctl"; DO NOT EDIT.

schema {
  query: Query
  mutation: Mutation
}

directive @weather_cacheControl(maxAge: Int, scope: weather_CacheControlScope) on FIELD_DEFINITION | INTERFACE | OBJECT

"""
The @removeNullVariables directive allows you to remove variables with null value from your GraphQL Query or Mutation Operations.

A potential use-case could be that you have a graphql upstream which is not accepting null values for variables.
By enabling this directive all variables with null values will be removed from upstream query.

query ($say: String, $name: String) @removeNullVariables {
	hello(say: $say, name: $name)
}

Directive will transform variables json and remove top level null values.
{ "say": null, "name": "world" }

So upstream will receive the following variables:

{ "name": "world" }
"""
directive @removeNullVariables on QUERY | MUTATION

directive @hooksVariable on VARIABLE_DEFINITION

directive @jsonSchema(
  """
  The value of both of these keywords MUST be a string.
  
  Both of these keywords can be used to decorate a user interface with
  information about the data produced by this user interface.  A title
  will preferably be short, whereas a description will provide
  explanation about the purpose of the instance described by this
  schema.
  """
  title: String
  """
  The value of both of these keywords MUST be a string.
  
  Both of these keywords can be used to decorate a user interface with
  information about the data produced by this user interface.  A title
  will preferably be short, whereas a description will provide
  explanation about the purpose of the instance described by this
  schema.
  """
  description: String
  """
  The value of "multipleOf" MUST be a number, strictly greater than 0.
  
  A numeric instance is valid only if division by this keyword's value
  results in an integer.
  """
  multipleOf: Int
  """
  The value of "maximum" MUST be a number, representing an inclusive
  upper limit for a numeric instance.
  
  If the instance is a number, then this keyword validates only if the
  instance is less than or exactly equal to "maximum".
  """
  maximum: Int
  """
  The value of "exclusiveMaximum" MUST be number, representing an
  exclusive upper limit for a numeric instance.
  
  If the instance is a number, then the instance is valid only if it
  has a value strictly less than (not equal to) "exclusiveMaximum".
  """
  exclusiveMaximum: Int
  """
  The value of "minimum" MUST be a number, representing an inclusive
  lower limit for a numeric instance.
  
  If the instance is a number, then this keyword validates only if the
  instance is greater than or exactly equal to "minimum".
  """
  minimum: Int
  """
  The value of "exclusiveMinimum" MUST be number, representing an
  exclusive lower limit for a numeric instance.
  
  If the instance is a number, then the instance is valid only if it
  has a value strictly greater than (not equal to) "exclusiveMinimum".
  """
  exclusiveMinimum: Int
  """
  The value of this keyword MUST be a non-negative integer.
  
  A string instance is valid against this keyword if its length is less
  than, or equal to, the value of this keyword.
  
  The length of a string instance is defined as the number of its
  characters as defined by RFC 7159 [RFC7159].
  """
  maxLength: Int
  """
  The value of this keyword MUST be a non-negative integer.
  
  A string instance is valid against this keyword if its length is
  greater than, or equal to, the value of this keyword.
  
  The length of a string instance is defined as the number of its
  characters as defined by RFC 7159 [RFC7159].
  
  Omitting this keyword has the same behavior as a value of 0.
  """
  minLength: Int
  """
  The value of this keyword MUST be a string.  This string SHOULD be a
  valid regular expression, according to the ECMA 262 regular
  expression dialect.
  
  A string instance is considered valid if the regular expression
  matches the instance successfully.  Recall: regular expressions are
  not implicitly anchored.
  """
  pattern: String
  """
  The value of this keyword MUST be a non-negative integer.
  
  An array instance is valid against "maxItems" if its size is less
  than, or equal to, the value of this keyword.
  """
  maxItems: Int
  """
  The value of this keyword MUST be a non-negative integer.
  
  An array instance is valid against "minItems" if its size is greater
  than, or equal to, the value of this keyword.
  
  Omitting this keyword has the same behavior as a value of 0.
  """
  minItems: Int
  """
  The value of this keyword MUST be a boolean.
  
  If this keyword has boolean value false, the instance validates
  successfully.  If it has boolean value true, the instance validates
  successfully if all of its elements are unique.
  
  Omitting this keyword has the same behavior as a value of false.
  """
  uniqueItems: Boolean
  commonPattern: COMMON_REGEX_PATTERN
  """Optional field to apply the JSON schema to"""
  on: String
) repeatable on VARIABLE_DEFINITION

directive @rbac(
  "the user must match all roles"
  requireMatchAll: [WG_ROLE]
  "the user must match at least one of the roles"
  requireMatchAny: [WG_ROLE]
  "the user must not match all of the roles"
  denyMatchAll: [WG_ROLE]
  "the user must not match any of the roles"
  denyMatchAny: [WG_ROLE]
) on QUERY | MUTATION | SUBSCRIPTION

"""
The @fromClaim directive sets the variable to the value retrieved from the given a claim.
Adding this directive makes the operation require authentication.
"""
directive @fromClaim(name: WG_CLAIM, on: String = "") repeatable on VARIABLE_DEFINITION

"""
The directive @injectCurrentDateTime injects a DateTime string of the current date and time into the variable.
This variable MUST be a string compatible scalar. 

The default format, is: ISO 8601
If no format is chosen, the default format is used.
Custom formats are allowed by specifying a format conforming to the Golang specification for specifying a date time format.
"""
directive @injectCurrentDateTime(
  format: WunderGraphDateTimeFormat = ISO8601
  """
  customFormat must conform to the Golang specification for specifying a date time format
  """
  customFormat: String
  on: String = ""
) repeatable on VARIABLE_DEFINITION

"""
The directive @injectGeneratedUUID injects a generated UUID into the variable.
This variable MUST be a string.
At the same time, it removes the variable from the input definition,
disallowing the user to supply it.

This means, the UUID is 100% generated server-side and can be considered untempered.
"""
directive @injectGeneratedUUID(on: String = "") repeatable on VARIABLE_DEFINITION

"""
The @internalOperation Directive marks an Operation as internal.
By doing so, the Operation is no longer accessible from the public API.
It can only be accessed by internal services, like hooks.
"""
directive @internalOperation on QUERY | MUTATION | SUBSCRIPTION

"""
The directive @injectEnvironmentVariable allows you to inject an environment variable into the variable definition.
"""
directive @injectEnvironmentVariable(name: String!, on: String = "") repeatable on VARIABLE_DEFINITION

"""
The @export directive instructs the Execution Planner to export the field during the execution into the variable of the 'as' argument.
As the execution is depth first, a field can only be used after it has been exported.
Additionally, a field can only be used after using the '_join' field or on a different data source.
It's not possible to export a field and use it in for the same data source.

Note that the @export directive only works on fields that return a single value.
It's not possible to export a list or object field.
"""
directive @export(
  """The argument 'as' is the name of the variable to export the field to."""
  as: String!
) on FIELD

"""
The directive @internal marks a variable definition as internal so that clients can't access it.
The field is also not visible in the public API.
It's only being used as an internal variable to export fields into.
"""
directive @internal on VARIABLE_DEFINITION

"""
The @transform directive allows to apply transformations to the response.
By applying the directive, the shape of the response can be altered,
which will also modify the JSON-Schema of the response.
That is, you will keep full type safety and code-generation for transformed fields.
"""
directive @transform(
  """
  Using the 'get' transformation allows you to extract a nested field using a JSON path.
  This is useful to unnest data, e.g. when using the '_join' field, which adds an extra layer of nesting.
  
  Example:
  
  query GetName {
      name: me @transform(get: "info.name") {
          info {
              name
          }
      }
  }
  
  Before the transformation, the resolve looks like this:
  
  {
      "name": {
          "info": {
              "name": "John Doe"
          }
      }
  }
  
  With the transformation applied, the response will be reshaped like this:
  
  {
      "name": "John Doe"
  }
  """
  get: String
) on FIELD

"""
The @requireAuthentication Directive marks an Operation to require authentication.
Without authentication, the operation will return an Unauthorized error with status code 401.
"""
directive @requireAuthentication on QUERY | MUTATION | SUBSCRIPTION

type countries_Continent {
  code: ID!
  countries: [countries_Country!]!
  name: String!
  _join: Query!
}

input countries_ContinentFilterInput {
  code: countries_StringQueryOperatorInput
}

type countries_Country {
  awsRegion: String!
  capital: String
  code: ID!
  continent: countries_Continent!
  currencies: [String!]!
  currency: String
  emoji: String!
  emojiU: String!
  languages: [countries_Language!]!
  name(lang: String): String!
  native: String!
  phone: String!
  phones: [String!]!
  states: [countries_State!]!
  subdivisions: [countries_Subdivision!]!
  _join: Query!
}

input countries_CountryFilterInput {
  code: countries_StringQueryOperatorInput
  continent: countries_StringQueryOperatorInput
  currency: countries_StringQueryOperatorInput
  name: countries_StringQueryOperatorInput
}

type countries_Language {
  code: ID!
  name: String!
  native: String!
  rtl: Boolean!
  _join: Query!
}

input countries_LanguageFilterInput {
  code: countries_StringQueryOperatorInput
}

type Query {
  countries_continent(code: ID!): countries_Continent
  countries_continents(filter: countries_ContinentFilterInput = {}): [countries_Continent!]!
  countries_countries(filter: countries_CountryFilterInput = {}): [countries_Country!]!
  countries_country(code: ID!): countries_Country
  countries_language(code: ID!): countries_Language
  countries_languages(filter: countries_LanguageFilterInput = {}): [countries_Language!]!
  db_findFirstAccount(where: db_AccountWhereInput, orderBy: [db_AccountOrderByWithRelationInput], cursor: db_AccountWhereUniqueInput, take: Int, skip: Int, distinct: [db_AccountScalarFieldEnum]): db_Account
  db_findFirstAccountOrThrow(where: db_AccountWhereInput, orderBy: [db_AccountOrderByWithRelationInput], cursor: db_AccountWhereUniqueInput, take: Int, skip: Int, distinct: [db_AccountScalarFieldEnum]): db_Account
  db_findManyAccount(where: db_AccountWhereInput, orderBy: [db_AccountOrderByWithRelationInput], cursor: db_AccountWhereUniqueInput, take: Int, skip: Int, distinct: [db_AccountScalarFieldEnum]): [db_Account]!
  db_aggregateAccount(where: db_AccountWhereInput, orderBy: [db_AccountOrderByWithRelationInput], cursor: db_AccountWhereUniqueInput, take: Int, skip: Int): db_AggregateAccount!
  db_groupByAccount(where: db_AccountWhereInput, orderBy: [db_AccountOrderByWithAggregationInput], by: [db_AccountScalarFieldEnum]!, having: db_AccountScalarWhereWithAggregatesInput, take: Int, skip: Int): [db_AccountGroupByOutputType]!
  db_findUniqueAccount(where: db_AccountWhereUniqueInput!): db_Account
  db_findUniqueAccountOrThrow(where: db_AccountWhereUniqueInput!): db_Account
  db_findFirstSession(where: db_SessionWhereInput, orderBy: [db_SessionOrderByWithRelationInput], cursor: db_SessionWhereUniqueInput, take: Int, skip: Int, distinct: [db_SessionScalarFieldEnum]): db_Session
  db_findFirstSessionOrThrow(where: db_SessionWhereInput, orderBy: [db_SessionOrderByWithRelationInput], cursor: db_SessionWhereUniqueInput, take: Int, skip: Int, distinct: [db_SessionScalarFieldEnum]): db_Session
  db_findManySession(where: db_SessionWhereInput, orderBy: [db_SessionOrderByWithRelationInput], cursor: db_SessionWhereUniqueInput, take: Int, skip: Int, distinct: [db_SessionScalarFieldEnum]): [db_Session]!
  db_aggregateSession(where: db_SessionWhereInput, orderBy: [db_SessionOrderByWithRelationInput], cursor: db_SessionWhereUniqueInput, take: Int, skip: Int): db_AggregateSession!
  db_groupBySession(where: db_SessionWhereInput, orderBy: [db_SessionOrderByWithAggregationInput], by: [db_SessionScalarFieldEnum]!, having: db_SessionScalarWhereWithAggregatesInput, take: Int, skip: Int): [db_SessionGroupByOutputType]!
  db_findUniqueSession(where: db_SessionWhereUniqueInput!): db_Session
  db_findUniqueSessionOrThrow(where: db_SessionWhereUniqueInput!): db_Session
  db_findFirstUser(where: db_UserWhereInput, orderBy: [db_UserOrderByWithRelationInput], cursor: db_UserWhereUniqueInput, take: Int, skip: Int, distinct: [db_UserScalarFieldEnum]): db_User
  db_findFirstUserOrThrow(where: db_UserWhereInput, orderBy: [db_UserOrderByWithRelationInput], cursor: db_UserWhereUniqueInput, take: Int, skip: Int, distinct: [db_UserScalarFieldEnum]): db_User
  db_findManyUser(where: db_UserWhereInput, orderBy: [db_UserOrderByWithRelationInput], cursor: db_UserWhereUniqueInput, take: Int, skip: Int, distinct: [db_UserScalarFieldEnum]): [db_User]!
  db_aggregateUser(where: db_UserWhereInput, orderBy: [db_UserOrderByWithRelationInput], cursor: db_UserWhereUniqueInput, take: Int, skip: Int): db_AggregateUser!
  db_groupByUser(where: db_UserWhereInput, orderBy: [db_UserOrderByWithAggregationInput], by: [db_UserScalarFieldEnum]!, having: db_UserScalarWhereWithAggregatesInput, take: Int, skip: Int): [db_UserGroupByOutputType]!
  db_findUniqueUser(where: db_UserWhereUniqueInput!): db_User
  db_findUniqueUserOrThrow(where: db_UserWhereUniqueInput!): db_User
  db_findFirstVerificationToken(where: db_VerificationTokenWhereInput, orderBy: [db_VerificationTokenOrderByWithRelationInput], cursor: db_VerificationTokenWhereUniqueInput, take: Int, skip: Int, distinct: [db_VerificationTokenScalarFieldEnum]): db_VerificationToken
  db_findFirstVerificationTokenOrThrow(where: db_VerificationTokenWhereInput, orderBy: [db_VerificationTokenOrderByWithRelationInput], cursor: db_VerificationTokenWhereUniqueInput, take: Int, skip: Int, distinct: [db_VerificationTokenScalarFieldEnum]): db_VerificationToken
  db_findManyVerificationToken(where: db_VerificationTokenWhereInput, orderBy: [db_VerificationTokenOrderByWithRelationInput], cursor: db_VerificationTokenWhereUniqueInput, take: Int, skip: Int, distinct: [db_VerificationTokenScalarFieldEnum]): [db_VerificationToken]!
  db_aggregateVerificationToken(where: db_VerificationTokenWhereInput, orderBy: [db_VerificationTokenOrderByWithRelationInput], cursor: db_VerificationTokenWhereUniqueInput, take: Int, skip: Int): db_AggregateVerificationToken!
  db_groupByVerificationToken(where: db_VerificationTokenWhereInput, orderBy: [db_VerificationTokenOrderByWithAggregationInput], by: [db_VerificationTokenScalarFieldEnum]!, having: db_VerificationTokenScalarWhereWithAggregatesInput, take: Int, skip: Int): [db_VerificationTokenGroupByOutputType]!
  db_findUniqueVerificationToken(where: db_VerificationTokenWhereUniqueInput!): db_VerificationToken
  db_findUniqueVerificationTokenOrThrow(where: db_VerificationTokenWhereUniqueInput!): db_VerificationToken
  db_findFirstPost(where: db_PostWhereInput, orderBy: [db_PostOrderByWithRelationInput], cursor: db_PostWhereUniqueInput, take: Int, skip: Int, distinct: [db_PostScalarFieldEnum]): db_Post
  db_findFirstPostOrThrow(where: db_PostWhereInput, orderBy: [db_PostOrderByWithRelationInput], cursor: db_PostWhereUniqueInput, take: Int, skip: Int, distinct: [db_PostScalarFieldEnum]): db_Post
  db_findManyPost(where: db_PostWhereInput, orderBy: [db_PostOrderByWithRelationInput], cursor: db_PostWhereUniqueInput, take: Int, skip: Int, distinct: [db_PostScalarFieldEnum]): [db_Post]!
  db_aggregatePost(where: db_PostWhereInput, orderBy: [db_PostOrderByWithRelationInput], cursor: db_PostWhereUniqueInput, take: Int, skip: Int): db_AggregatePost!
  db_groupByPost(where: db_PostWhereInput, orderBy: [db_PostOrderByWithAggregationInput], by: [db_PostScalarFieldEnum]!, having: db_PostScalarWhereWithAggregatesInput, take: Int, skip: Int): [db_PostGroupByOutputType]!
  db_findUniquePost(where: db_PostWhereUniqueInput!): db_Post
  db_findUniquePostOrThrow(where: db_PostWhereUniqueInput!): db_Post
  db_findFirstTodo(where: db_TodoWhereInput, orderBy: [db_TodoOrderByWithRelationInput], cursor: db_TodoWhereUniqueInput, take: Int, skip: Int, distinct: [db_TodoScalarFieldEnum]): db_Todo
  db_findFirstTodoOrThrow(where: db_TodoWhereInput, orderBy: [db_TodoOrderByWithRelationInput], cursor: db_TodoWhereUniqueInput, take: Int, skip: Int, distinct: [db_TodoScalarFieldEnum]): db_Todo
  db_findManyTodo(where: db_TodoWhereInput, orderBy: [db_TodoOrderByWithRelationInput], cursor: db_TodoWhereUniqueInput, take: Int, skip: Int, distinct: [db_TodoScalarFieldEnum]): [db_Todo]!
  db_aggregateTodo(where: db_TodoWhereInput, orderBy: [db_TodoOrderByWithRelationInput], cursor: db_TodoWhereUniqueInput, take: Int, skip: Int): db_AggregateTodo!
  db_groupByTodo(where: db_TodoWhereInput, orderBy: [db_TodoOrderByWithAggregationInput], by: [db_TodoScalarFieldEnum]!, having: db_TodoScalarWhereWithAggregatesInput, take: Int, skip: Int): [db_TodoGroupByOutputType]!
  db_findUniqueTodo(where: db_TodoWhereUniqueInput!): db_Todo
  db_findUniqueTodoOrThrow(where: db_TodoWhereUniqueInput!): db_Todo
  db_queryRaw(query: String!, parameters: [String]): [_Row!]!
  db_queryRawJSON(query: String!, parameters: [String]): JSON
  weather_getCityById(config: weather_ConfigInput, id: [String!]): [weather_City]
  weather_getCityByName(config: weather_ConfigInput, country: String, name: String!): weather_City
}

type countries_State {
  code: String
  country: countries_Country!
  name: String!
  _join: Query!
}

input countries_StringQueryOperatorInput {
  eq: String
  in: [String!]
  ne: String
  nin: [String!]
  regex: String
}

type countries_Subdivision {
  code: ID!
  emoji: String
  name: String!
  _join: Query!
}

input db_NestedStringFilter {
  equals: String
  in: [String]
  notIn: [String]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: db_NestedStringFilter
}

input db_StringFilter {
  equals: String
  in: [String]
  notIn: [String]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: db_NestedStringFilter
}

input db_NestedStringNullableFilter {
  equals: String
  in: [String]
  notIn: [String]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: db_NestedStringNullableFilter
}

input db_StringNullableFilter {
  equals: String
  in: [String]
  notIn: [String]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: db_NestedStringNullableFilter
}

input db_NestedIntNullableFilter {
  equals: Int
  in: [Int]
  notIn: [Int]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: db_NestedIntNullableFilter
}

input db_IntNullableFilter {
  equals: Int
  in: [Int]
  notIn: [Int]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: db_NestedIntNullableFilter
}

input db_NestedDateTimeFilter {
  equals: DateTime
  in: [DateTime]
  notIn: [DateTime]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: db_NestedDateTimeFilter
}

input db_DateTimeFilter {
  equals: DateTime
  in: [DateTime]
  notIn: [DateTime]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: db_NestedDateTimeFilter
}

input db_NestedDateTimeNullableFilter {
  equals: DateTime
  in: [DateTime]
  notIn: [DateTime]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: db_NestedDateTimeNullableFilter
}

input db_DateTimeNullableFilter {
  equals: DateTime
  in: [DateTime]
  notIn: [DateTime]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: db_NestedDateTimeNullableFilter
}

input db_AccountListRelationFilter {
  every: db_AccountWhereInput
  some: db_AccountWhereInput
  none: db_AccountWhereInput
}

input db_SessionWhereInput {
  AND: db_SessionWhereInput
  OR: [db_SessionWhereInput]
  NOT: db_SessionWhereInput
  id: db_StringFilter
  sessionToken: db_StringFilter
  userId: db_StringFilter
  expires: db_DateTimeFilter
  user: db_UserRelationFilter
}

input db_SessionListRelationFilter {
  every: db_SessionWhereInput
  some: db_SessionWhereInput
  none: db_SessionWhereInput
}

input db_JsonNullableFilter {
  equals: JSON
  path: String
  string_contains: String
  string_starts_with: String
  string_ends_with: String
  array_contains: JSON
  array_starts_with: JSON
  array_ends_with: JSON
  lt: JSON
  lte: JSON
  gt: JSON
  gte: JSON
  not: JSON
}

input db_NestedBoolFilter {
  equals: Boolean
  not: db_NestedBoolFilter
}

input db_BoolFilter {
  equals: Boolean
  not: db_NestedBoolFilter
}

input db_PostWhereInput {
  AND: db_PostWhereInput
  OR: [db_PostWhereInput]
  NOT: db_PostWhereInput
  id: db_StringFilter
  title: db_StringFilter
  content: db_JsonNullableFilter
  published: db_BoolFilter
  createdAt: db_DateTimeFilter
  updatedAt: db_DateTimeFilter
  authorId: db_StringFilter
  author: db_UserRelationFilter
}

input db_PostListRelationFilter {
  every: db_PostWhereInput
  some: db_PostWhereInput
  none: db_PostWhereInput
}

input db_TodoWhereInput {
  AND: db_TodoWhereInput
  OR: [db_TodoWhereInput]
  NOT: db_TodoWhereInput
  id: db_StringFilter
  text: db_StringFilter
  isCompleted: db_BoolFilter
  createdAt: db_DateTimeFilter
  updatedAt: db_DateTimeFilter
  userId: db_StringFilter
  user: db_UserRelationFilter
}

input db_TodoListRelationFilter {
  every: db_TodoWhereInput
  some: db_TodoWhereInput
  none: db_TodoWhereInput
}

input db_UserWhereInput {
  AND: db_UserWhereInput
  OR: [db_UserWhereInput]
  NOT: db_UserWhereInput
  id: db_StringFilter
  name: db_StringNullableFilter
  email: db_StringNullableFilter
  emailVerified: db_DateTimeNullableFilter
  image: db_StringNullableFilter
  createdAt: db_DateTimeFilter
  updatedAt: db_DateTimeFilter
  stripeCustomerId: db_StringNullableFilter
  stripeSubscriptionId: db_StringNullableFilter
  stripePriceId: db_StringNullableFilter
  stripeCurrentPeriodEnd: db_DateTimeNullableFilter
  accounts: db_AccountListRelationFilter
  sessions: db_SessionListRelationFilter
  Post: db_PostListRelationFilter
  Todo: db_TodoListRelationFilter
}

input db_UserRelationFilter {
  is: db_UserWhereInput
  isNot: db_UserWhereInput
}

input db_AccountWhereInput {
  AND: db_AccountWhereInput
  OR: [db_AccountWhereInput]
  NOT: db_AccountWhereInput
  id: db_StringFilter
  userId: db_StringFilter
  type: db_StringFilter
  provider: db_StringFilter
  providerAccountId: db_StringFilter
  refresh_token: db_StringNullableFilter
  access_token: db_StringNullableFilter
  expires_at: db_IntNullableFilter
  token_type: db_StringNullableFilter
  scope: db_StringNullableFilter
  id_token: db_StringNullableFilter
  session_state: db_StringNullableFilter
  createdAt: db_DateTimeFilter
  updatedAt: db_DateTimeFilter
  user: db_UserRelationFilter
}

enum db_SortOrder {
  asc
  desc
}

input db_AccountOrderByRelationAggregateInput {
  _count: db_SortOrder
}

input db_SessionOrderByRelationAggregateInput {
  _count: db_SortOrder
}

input db_PostOrderByRelationAggregateInput {
  _count: db_SortOrder
}

input db_TodoOrderByRelationAggregateInput {
  _count: db_SortOrder
}

input db_UserOrderByWithRelationInput {
  id: db_SortOrder
  name: db_SortOrder
  email: db_SortOrder
  emailVerified: db_SortOrder
  image: db_SortOrder
  createdAt: db_SortOrder
  updatedAt: db_SortOrder
  stripeCustomerId: db_SortOrder
  stripeSubscriptionId: db_SortOrder
  stripePriceId: db_SortOrder
  stripeCurrentPeriodEnd: db_SortOrder
  accounts: db_AccountOrderByRelationAggregateInput
  sessions: db_SessionOrderByRelationAggregateInput
  Post: db_PostOrderByRelationAggregateInput
  Todo: db_TodoOrderByRelationAggregateInput
}

input db_AccountOrderByWithRelationInput {
  id: db_SortOrder
  userId: db_SortOrder
  type: db_SortOrder
  provider: db_SortOrder
  providerAccountId: db_SortOrder
  refresh_token: db_SortOrder
  access_token: db_SortOrder
  expires_at: db_SortOrder
  token_type: db_SortOrder
  scope: db_SortOrder
  id_token: db_SortOrder
  session_state: db_SortOrder
  createdAt: db_SortOrder
  updatedAt: db_SortOrder
  user: db_UserOrderByWithRelationInput
}

input db_AccountProviderProviderAccountIdCompoundUniqueInput {
  provider: String!
  providerAccountId: String!
}

input db_AccountWhereUniqueInput {
  id: String
  provider_providerAccountId: db_AccountProviderProviderAccountIdCompoundUniqueInput
}

enum db_AccountScalarFieldEnum {
  id
  userId
  type
  provider
  providerAccountId
  refresh_token
  access_token
  expires_at
  token_type
  scope
  id_token
  session_state
  createdAt
  updatedAt
}

input db_SessionOrderByWithRelationInput {
  id: db_SortOrder
  sessionToken: db_SortOrder
  userId: db_SortOrder
  expires: db_SortOrder
  user: db_UserOrderByWithRelationInput
}

input db_SessionWhereUniqueInput {
  id: String
  sessionToken: String
}

enum db_SessionScalarFieldEnum {
  id
  sessionToken
  userId
  expires
}

type db_Session {
  id: String!
  sessionToken: String!
  userId: String!
  expires: DateTime!
  user: db_User!
  _join: Query!
}

input db_PostOrderByWithRelationInput {
  id: db_SortOrder
  title: db_SortOrder
  content: db_SortOrder
  published: db_SortOrder
  createdAt: db_SortOrder
  updatedAt: db_SortOrder
  authorId: db_SortOrder
  author: db_UserOrderByWithRelationInput
}

input db_PostWhereUniqueInput {
  id: String
}

enum db_PostScalarFieldEnum {
  id
  title
  content
  published
  createdAt
  updatedAt
  authorId
}

type db_Post {
  id: String!
  title: String!
  content: JSON
  published: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  authorId: String!
  author: db_User!
  _join: Query!
}

input db_TodoOrderByWithRelationInput {
  id: db_SortOrder
  text: db_SortOrder
  isCompleted: db_SortOrder
  createdAt: db_SortOrder
  updatedAt: db_SortOrder
  userId: db_SortOrder
  user: db_UserOrderByWithRelationInput
}

input db_TodoWhereUniqueInput {
  id: String
}

enum db_TodoScalarFieldEnum {
  id
  text
  isCompleted
  createdAt
  updatedAt
  userId
}

type db_Todo {
  id: String!
  text: String!
  isCompleted: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  userId: String!
  user: db_User!
  _join: Query!
}

type db_UserCountOutputType {
  accounts: Int!
  sessions: Int!
  Post: Int!
  Todo: Int!
  _join: Query!
}

type db_User {
  id: String!
  name: String
  email: String
  emailVerified: DateTime
  image: String
  createdAt: DateTime!
  updatedAt: DateTime!
  stripeCustomerId: String
  stripeSubscriptionId: String
  stripePriceId: String
  stripeCurrentPeriodEnd: DateTime
  accounts(where: db_AccountWhereInput, orderBy: [db_AccountOrderByWithRelationInput], cursor: db_AccountWhereUniqueInput, take: Int, skip: Int, distinct: [db_AccountScalarFieldEnum]): [db_Account]
  sessions(where: db_SessionWhereInput, orderBy: [db_SessionOrderByWithRelationInput], cursor: db_SessionWhereUniqueInput, take: Int, skip: Int, distinct: [db_SessionScalarFieldEnum]): [db_Session]
  Post(where: db_PostWhereInput, orderBy: [db_PostOrderByWithRelationInput], cursor: db_PostWhereUniqueInput, take: Int, skip: Int, distinct: [db_PostScalarFieldEnum]): [db_Post]
  Todo(where: db_TodoWhereInput, orderBy: [db_TodoOrderByWithRelationInput], cursor: db_TodoWhereUniqueInput, take: Int, skip: Int, distinct: [db_TodoScalarFieldEnum]): [db_Todo]
  _count: db_UserCountOutputType!
  _join: Query!
}

type db_Account {
  id: String!
  userId: String!
  type: String!
  provider: String!
  providerAccountId: String!
  refresh_token: String
  access_token: String
  expires_at: Int
  token_type: String
  scope: String
  id_token: String
  session_state: String
  createdAt: DateTime!
  updatedAt: DateTime!
  user: db_User!
  _join: Query!
}

type db_AccountCountAggregateOutputType {
  id: Int!
  userId: Int!
  type: Int!
  provider: Int!
  providerAccountId: Int!
  refresh_token: Int!
  access_token: Int!
  expires_at: Int!
  token_type: Int!
  scope: Int!
  id_token: Int!
  session_state: Int!
  createdAt: Int!
  updatedAt: Int!
  _all: Int!
  _join: Query!
}

type db_AccountAvgAggregateOutputType {
  expires_at: Float
  _join: Query!
}

type db_AccountSumAggregateOutputType {
  expires_at: Int
  _join: Query!
}

type db_AccountMinAggregateOutputType {
  id: String
  userId: String
  type: String
  provider: String
  providerAccountId: String
  refresh_token: String
  access_token: String
  expires_at: Int
  token_type: String
  scope: String
  id_token: String
  session_state: String
  createdAt: DateTime
  updatedAt: DateTime
  _join: Query!
}

type db_AccountMaxAggregateOutputType {
  id: String
  userId: String
  type: String
  provider: String
  providerAccountId: String
  refresh_token: String
  access_token: String
  expires_at: Int
  token_type: String
  scope: String
  id_token: String
  session_state: String
  createdAt: DateTime
  updatedAt: DateTime
  _join: Query!
}

type db_AggregateAccount {
  _count: db_AccountCountAggregateOutputType
  _avg: db_AccountAvgAggregateOutputType
  _sum: db_AccountSumAggregateOutputType
  _min: db_AccountMinAggregateOutputType
  _max: db_AccountMaxAggregateOutputType
  _join: Query!
}

input db_AccountCountOrderByAggregateInput {
  id: db_SortOrder
  userId: db_SortOrder
  type: db_SortOrder
  provider: db_SortOrder
  providerAccountId: db_SortOrder
  refresh_token: db_SortOrder
  access_token: db_SortOrder
  expires_at: db_SortOrder
  token_type: db_SortOrder
  scope: db_SortOrder
  id_token: db_SortOrder
  session_state: db_SortOrder
  createdAt: db_SortOrder
  updatedAt: db_SortOrder
}

input db_AccountAvgOrderByAggregateInput {
  expires_at: db_SortOrder
}

input db_AccountMaxOrderByAggregateInput {
  id: db_SortOrder
  userId: db_SortOrder
  type: db_SortOrder
  provider: db_SortOrder
  providerAccountId: db_SortOrder
  refresh_token: db_SortOrder
  access_token: db_SortOrder
  expires_at: db_SortOrder
  token_type: db_SortOrder
  scope: db_SortOrder
  id_token: db_SortOrder
  session_state: db_SortOrder
  createdAt: db_SortOrder
  updatedAt: db_SortOrder
}

input db_AccountMinOrderByAggregateInput {
  id: db_SortOrder
  userId: db_SortOrder
  type: db_SortOrder
  provider: db_SortOrder
  providerAccountId: db_SortOrder
  refresh_token: db_SortOrder
  access_token: db_SortOrder
  expires_at: db_SortOrder
  token_type: db_SortOrder
  scope: db_SortOrder
  id_token: db_SortOrder
  session_state: db_SortOrder
  createdAt: db_SortOrder
  updatedAt: db_SortOrder
}

input db_AccountSumOrderByAggregateInput {
  expires_at: db_SortOrder
}

input db_AccountOrderByWithAggregationInput {
  id: db_SortOrder
  userId: db_SortOrder
  type: db_SortOrder
  provider: db_SortOrder
  providerAccountId: db_SortOrder
  refresh_token: db_SortOrder
  access_token: db_SortOrder
  expires_at: db_SortOrder
  token_type: db_SortOrder
  scope: db_SortOrder
  id_token: db_SortOrder
  session_state: db_SortOrder
  createdAt: db_SortOrder
  updatedAt: db_SortOrder
  _count: db_AccountCountOrderByAggregateInput
  _avg: db_AccountAvgOrderByAggregateInput
  _max: db_AccountMaxOrderByAggregateInput
  _min: db_AccountMinOrderByAggregateInput
  _sum: db_AccountSumOrderByAggregateInput
}

input db_NestedIntFilter {
  equals: Int
  in: [Int]
  notIn: [Int]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: db_NestedIntFilter
}

input db_NestedStringWithAggregatesFilter {
  equals: String
  in: [String]
  notIn: [String]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: db_NestedStringWithAggregatesFilter
  _count: db_NestedIntFilter
  _min: db_NestedStringFilter
  _max: db_NestedStringFilter
}

input db_StringWithAggregatesFilter {
  equals: String
  in: [String]
  notIn: [String]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: db_NestedStringWithAggregatesFilter
  _count: db_NestedIntFilter
  _min: db_NestedStringFilter
  _max: db_NestedStringFilter
}

input db_NestedStringNullableWithAggregatesFilter {
  equals: String
  in: [String]
  notIn: [String]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: db_NestedStringNullableWithAggregatesFilter
  _count: db_NestedIntNullableFilter
  _min: db_NestedStringNullableFilter
  _max: db_NestedStringNullableFilter
}

input db_StringNullableWithAggregatesFilter {
  equals: String
  in: [String]
  notIn: [String]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: db_NestedStringNullableWithAggregatesFilter
  _count: db_NestedIntNullableFilter
  _min: db_NestedStringNullableFilter
  _max: db_NestedStringNullableFilter
}

input db_NestedFloatNullableFilter {
  equals: Float
  in: [Float]
  notIn: [Float]
  lt: Float
  lte: Float
  gt: Float
  gte: Float
  not: db_NestedFloatNullableFilter
}

input db_NestedIntNullableWithAggregatesFilter {
  equals: Int
  in: [Int]
  notIn: [Int]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: db_NestedIntNullableWithAggregatesFilter
  _count: db_NestedIntNullableFilter
  _avg: db_NestedFloatNullableFilter
  _sum: db_NestedIntNullableFilter
  _min: db_NestedIntNullableFilter
  _max: db_NestedIntNullableFilter
}

input db_IntNullableWithAggregatesFilter {
  equals: Int
  in: [Int]
  notIn: [Int]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: db_NestedIntNullableWithAggregatesFilter
  _count: db_NestedIntNullableFilter
  _avg: db_NestedFloatNullableFilter
  _sum: db_NestedIntNullableFilter
  _min: db_NestedIntNullableFilter
  _max: db_NestedIntNullableFilter
}

input db_NestedDateTimeWithAggregatesFilter {
  equals: DateTime
  in: [DateTime]
  notIn: [DateTime]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: db_NestedDateTimeWithAggregatesFilter
  _count: db_NestedIntFilter
  _min: db_NestedDateTimeFilter
  _max: db_NestedDateTimeFilter
}

input db_DateTimeWithAggregatesFilter {
  equals: DateTime
  in: [DateTime]
  notIn: [DateTime]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: db_NestedDateTimeWithAggregatesFilter
  _count: db_NestedIntFilter
  _min: db_NestedDateTimeFilter
  _max: db_NestedDateTimeFilter
}

input db_AccountScalarWhereWithAggregatesInput {
  AND: db_AccountScalarWhereWithAggregatesInput
  OR: [db_AccountScalarWhereWithAggregatesInput]
  NOT: db_AccountScalarWhereWithAggregatesInput
  id: db_StringWithAggregatesFilter
  userId: db_StringWithAggregatesFilter
  type: db_StringWithAggregatesFilter
  provider: db_StringWithAggregatesFilter
  providerAccountId: db_StringWithAggregatesFilter
  refresh_token: db_StringNullableWithAggregatesFilter
  access_token: db_StringNullableWithAggregatesFilter
  expires_at: db_IntNullableWithAggregatesFilter
  token_type: db_StringNullableWithAggregatesFilter
  scope: db_StringNullableWithAggregatesFilter
  id_token: db_StringNullableWithAggregatesFilter
  session_state: db_StringNullableWithAggregatesFilter
  createdAt: db_DateTimeWithAggregatesFilter
  updatedAt: db_DateTimeWithAggregatesFilter
}

type db_AccountGroupByOutputType {
  id: String!
  userId: String!
  type: String!
  provider: String!
  providerAccountId: String!
  refresh_token: String
  access_token: String
  expires_at: Int
  token_type: String
  scope: String
  id_token: String
  session_state: String
  createdAt: DateTime!
  updatedAt: DateTime!
  _count: db_AccountCountAggregateOutputType
  _avg: db_AccountAvgAggregateOutputType
  _sum: db_AccountSumAggregateOutputType
  _min: db_AccountMinAggregateOutputType
  _max: db_AccountMaxAggregateOutputType
  _join: Query!
}

type db_SessionCountAggregateOutputType {
  id: Int!
  sessionToken: Int!
  userId: Int!
  expires: Int!
  _all: Int!
  _join: Query!
}

type db_SessionMinAggregateOutputType {
  id: String
  sessionToken: String
  userId: String
  expires: DateTime
  _join: Query!
}

type db_SessionMaxAggregateOutputType {
  id: String
  sessionToken: String
  userId: String
  expires: DateTime
  _join: Query!
}

type db_AggregateSession {
  _count: db_SessionCountAggregateOutputType
  _min: db_SessionMinAggregateOutputType
  _max: db_SessionMaxAggregateOutputType
  _join: Query!
}

input db_SessionCountOrderByAggregateInput {
  id: db_SortOrder
  sessionToken: db_SortOrder
  userId: db_SortOrder
  expires: db_SortOrder
}

input db_SessionMaxOrderByAggregateInput {
  id: db_SortOrder
  sessionToken: db_SortOrder
  userId: db_SortOrder
  expires: db_SortOrder
}

input db_SessionMinOrderByAggregateInput {
  id: db_SortOrder
  sessionToken: db_SortOrder
  userId: db_SortOrder
  expires: db_SortOrder
}

input db_SessionOrderByWithAggregationInput {
  id: db_SortOrder
  sessionToken: db_SortOrder
  userId: db_SortOrder
  expires: db_SortOrder
  _count: db_SessionCountOrderByAggregateInput
  _max: db_SessionMaxOrderByAggregateInput
  _min: db_SessionMinOrderByAggregateInput
}

input db_SessionScalarWhereWithAggregatesInput {
  AND: db_SessionScalarWhereWithAggregatesInput
  OR: [db_SessionScalarWhereWithAggregatesInput]
  NOT: db_SessionScalarWhereWithAggregatesInput
  id: db_StringWithAggregatesFilter
  sessionToken: db_StringWithAggregatesFilter
  userId: db_StringWithAggregatesFilter
  expires: db_DateTimeWithAggregatesFilter
}

type db_SessionGroupByOutputType {
  id: String!
  sessionToken: String!
  userId: String!
  expires: DateTime!
  _count: db_SessionCountAggregateOutputType
  _min: db_SessionMinAggregateOutputType
  _max: db_SessionMaxAggregateOutputType
  _join: Query!
}

input db_UserWhereUniqueInput {
  id: String
  email: String
  stripeCustomerId: String
  stripeSubscriptionId: String
}

enum db_UserScalarFieldEnum {
  id
  name
  email
  emailVerified
  image
  createdAt
  updatedAt
  stripeCustomerId
  stripeSubscriptionId
  stripePriceId
  stripeCurrentPeriodEnd
}

type db_UserCountAggregateOutputType {
  id: Int!
  name: Int!
  email: Int!
  emailVerified: Int!
  image: Int!
  createdAt: Int!
  updatedAt: Int!
  stripeCustomerId: Int!
  stripeSubscriptionId: Int!
  stripePriceId: Int!
  stripeCurrentPeriodEnd: Int!
  _all: Int!
  _join: Query!
}

type db_UserMinAggregateOutputType {
  id: String
  name: String
  email: String
  emailVerified: DateTime
  image: String
  createdAt: DateTime
  updatedAt: DateTime
  stripeCustomerId: String
  stripeSubscriptionId: String
  stripePriceId: String
  stripeCurrentPeriodEnd: DateTime
  _join: Query!
}

type db_UserMaxAggregateOutputType {
  id: String
  name: String
  email: String
  emailVerified: DateTime
  image: String
  createdAt: DateTime
  updatedAt: DateTime
  stripeCustomerId: String
  stripeSubscriptionId: String
  stripePriceId: String
  stripeCurrentPeriodEnd: DateTime
  _join: Query!
}

type db_AggregateUser {
  _count: db_UserCountAggregateOutputType
  _min: db_UserMinAggregateOutputType
  _max: db_UserMaxAggregateOutputType
  _join: Query!
}

input db_UserCountOrderByAggregateInput {
  id: db_SortOrder
  name: db_SortOrder
  email: db_SortOrder
  emailVerified: db_SortOrder
  image: db_SortOrder
  createdAt: db_SortOrder
  updatedAt: db_SortOrder
  stripeCustomerId: db_SortOrder
  stripeSubscriptionId: db_SortOrder
  stripePriceId: db_SortOrder
  stripeCurrentPeriodEnd: db_SortOrder
}

input db_UserMaxOrderByAggregateInput {
  id: db_SortOrder
  name: db_SortOrder
  email: db_SortOrder
  emailVerified: db_SortOrder
  image: db_SortOrder
  createdAt: db_SortOrder
  updatedAt: db_SortOrder
  stripeCustomerId: db_SortOrder
  stripeSubscriptionId: db_SortOrder
  stripePriceId: db_SortOrder
  stripeCurrentPeriodEnd: db_SortOrder
}

input db_UserMinOrderByAggregateInput {
  id: db_SortOrder
  name: db_SortOrder
  email: db_SortOrder
  emailVerified: db_SortOrder
  image: db_SortOrder
  createdAt: db_SortOrder
  updatedAt: db_SortOrder
  stripeCustomerId: db_SortOrder
  stripeSubscriptionId: db_SortOrder
  stripePriceId: db_SortOrder
  stripeCurrentPeriodEnd: db_SortOrder
}

input db_UserOrderByWithAggregationInput {
  id: db_SortOrder
  name: db_SortOrder
  email: db_SortOrder
  emailVerified: db_SortOrder
  image: db_SortOrder
  createdAt: db_SortOrder
  updatedAt: db_SortOrder
  stripeCustomerId: db_SortOrder
  stripeSubscriptionId: db_SortOrder
  stripePriceId: db_SortOrder
  stripeCurrentPeriodEnd: db_SortOrder
  _count: db_UserCountOrderByAggregateInput
  _max: db_UserMaxOrderByAggregateInput
  _min: db_UserMinOrderByAggregateInput
}

input db_NestedDateTimeNullableWithAggregatesFilter {
  equals: DateTime
  in: [DateTime]
  notIn: [DateTime]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: db_NestedDateTimeNullableWithAggregatesFilter
  _count: db_NestedIntNullableFilter
  _min: db_NestedDateTimeNullableFilter
  _max: db_NestedDateTimeNullableFilter
}

input db_DateTimeNullableWithAggregatesFilter {
  equals: DateTime
  in: [DateTime]
  notIn: [DateTime]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: db_NestedDateTimeNullableWithAggregatesFilter
  _count: db_NestedIntNullableFilter
  _min: db_NestedDateTimeNullableFilter
  _max: db_NestedDateTimeNullableFilter
}

input db_UserScalarWhereWithAggregatesInput {
  AND: db_UserScalarWhereWithAggregatesInput
  OR: [db_UserScalarWhereWithAggregatesInput]
  NOT: db_UserScalarWhereWithAggregatesInput
  id: db_StringWithAggregatesFilter
  name: db_StringNullableWithAggregatesFilter
  email: db_StringNullableWithAggregatesFilter
  emailVerified: db_DateTimeNullableWithAggregatesFilter
  image: db_StringNullableWithAggregatesFilter
  createdAt: db_DateTimeWithAggregatesFilter
  updatedAt: db_DateTimeWithAggregatesFilter
  stripeCustomerId: db_StringNullableWithAggregatesFilter
  stripeSubscriptionId: db_StringNullableWithAggregatesFilter
  stripePriceId: db_StringNullableWithAggregatesFilter
  stripeCurrentPeriodEnd: db_DateTimeNullableWithAggregatesFilter
}

type db_UserGroupByOutputType {
  id: String!
  name: String
  email: String
  emailVerified: DateTime
  image: String
  createdAt: DateTime!
  updatedAt: DateTime!
  stripeCustomerId: String
  stripeSubscriptionId: String
  stripePriceId: String
  stripeCurrentPeriodEnd: DateTime
  _count: db_UserCountAggregateOutputType
  _min: db_UserMinAggregateOutputType
  _max: db_UserMaxAggregateOutputType
  _join: Query!
}

input db_VerificationTokenWhereInput {
  AND: db_VerificationTokenWhereInput
  OR: [db_VerificationTokenWhereInput]
  NOT: db_VerificationTokenWhereInput
  identifier: db_StringFilter
  token: db_StringFilter
  expires: db_DateTimeFilter
}

input db_VerificationTokenOrderByWithRelationInput {
  identifier: db_SortOrder
  token: db_SortOrder
  expires: db_SortOrder
}

input db_VerificationTokenIdentifierTokenCompoundUniqueInput {
  identifier: String!
  token: String!
}

input db_VerificationTokenWhereUniqueInput {
  token: String
  identifier_token: db_VerificationTokenIdentifierTokenCompoundUniqueInput
}

enum db_VerificationTokenScalarFieldEnum {
  identifier
  token
  expires
}

type db_VerificationToken {
  identifier: String!
  token: String!
  expires: DateTime!
  _join: Query!
}

type db_VerificationTokenCountAggregateOutputType {
  identifier: Int!
  token: Int!
  expires: Int!
  _all: Int!
  _join: Query!
}

type db_VerificationTokenMinAggregateOutputType {
  identifier: String
  token: String
  expires: DateTime
  _join: Query!
}

type db_VerificationTokenMaxAggregateOutputType {
  identifier: String
  token: String
  expires: DateTime
  _join: Query!
}

type db_AggregateVerificationToken {
  _count: db_VerificationTokenCountAggregateOutputType
  _min: db_VerificationTokenMinAggregateOutputType
  _max: db_VerificationTokenMaxAggregateOutputType
  _join: Query!
}

input db_VerificationTokenCountOrderByAggregateInput {
  identifier: db_SortOrder
  token: db_SortOrder
  expires: db_SortOrder
}

input db_VerificationTokenMaxOrderByAggregateInput {
  identifier: db_SortOrder
  token: db_SortOrder
  expires: db_SortOrder
}

input db_VerificationTokenMinOrderByAggregateInput {
  identifier: db_SortOrder
  token: db_SortOrder
  expires: db_SortOrder
}

input db_VerificationTokenOrderByWithAggregationInput {
  identifier: db_SortOrder
  token: db_SortOrder
  expires: db_SortOrder
  _count: db_VerificationTokenCountOrderByAggregateInput
  _max: db_VerificationTokenMaxOrderByAggregateInput
  _min: db_VerificationTokenMinOrderByAggregateInput
}

input db_VerificationTokenScalarWhereWithAggregatesInput {
  AND: db_VerificationTokenScalarWhereWithAggregatesInput
  OR: [db_VerificationTokenScalarWhereWithAggregatesInput]
  NOT: db_VerificationTokenScalarWhereWithAggregatesInput
  identifier: db_StringWithAggregatesFilter
  token: db_StringWithAggregatesFilter
  expires: db_DateTimeWithAggregatesFilter
}

type db_VerificationTokenGroupByOutputType {
  identifier: String!
  token: String!
  expires: DateTime!
  _count: db_VerificationTokenCountAggregateOutputType
  _min: db_VerificationTokenMinAggregateOutputType
  _max: db_VerificationTokenMaxAggregateOutputType
  _join: Query!
}

type db_PostCountAggregateOutputType {
  id: Int!
  title: Int!
  content: Int!
  published: Int!
  createdAt: Int!
  updatedAt: Int!
  authorId: Int!
  _all: Int!
  _join: Query!
}

type db_PostMinAggregateOutputType {
  id: String
  title: String
  published: Boolean
  createdAt: DateTime
  updatedAt: DateTime
  authorId: String
  _join: Query!
}

type db_PostMaxAggregateOutputType {
  id: String
  title: String
  published: Boolean
  createdAt: DateTime
  updatedAt: DateTime
  authorId: String
  _join: Query!
}

type db_AggregatePost {
  _count: db_PostCountAggregateOutputType
  _min: db_PostMinAggregateOutputType
  _max: db_PostMaxAggregateOutputType
  _join: Query!
}

input db_PostCountOrderByAggregateInput {
  id: db_SortOrder
  title: db_SortOrder
  content: db_SortOrder
  published: db_SortOrder
  createdAt: db_SortOrder
  updatedAt: db_SortOrder
  authorId: db_SortOrder
}

input db_PostMaxOrderByAggregateInput {
  id: db_SortOrder
  title: db_SortOrder
  published: db_SortOrder
  createdAt: db_SortOrder
  updatedAt: db_SortOrder
  authorId: db_SortOrder
}

input db_PostMinOrderByAggregateInput {
  id: db_SortOrder
  title: db_SortOrder
  published: db_SortOrder
  createdAt: db_SortOrder
  updatedAt: db_SortOrder
  authorId: db_SortOrder
}

input db_PostOrderByWithAggregationInput {
  id: db_SortOrder
  title: db_SortOrder
  content: db_SortOrder
  published: db_SortOrder
  createdAt: db_SortOrder
  updatedAt: db_SortOrder
  authorId: db_SortOrder
  _count: db_PostCountOrderByAggregateInput
  _max: db_PostMaxOrderByAggregateInput
  _min: db_PostMinOrderByAggregateInput
}

input db_NestedJsonNullableFilter {
  equals: JSON
  path: String
  string_contains: String
  string_starts_with: String
  string_ends_with: String
  array_contains: JSON
  array_starts_with: JSON
  array_ends_with: JSON
  lt: JSON
  lte: JSON
  gt: JSON
  gte: JSON
  not: JSON
}

input db_JsonNullableWithAggregatesFilter {
  equals: JSON
  path: String
  string_contains: String
  string_starts_with: String
  string_ends_with: String
  array_contains: JSON
  array_starts_with: JSON
  array_ends_with: JSON
  lt: JSON
  lte: JSON
  gt: JSON
  gte: JSON
  not: JSON
  _count: db_NestedIntNullableFilter
  _min: db_NestedJsonNullableFilter
  _max: db_NestedJsonNullableFilter
}

input db_NestedBoolWithAggregatesFilter {
  equals: Boolean
  not: db_NestedBoolWithAggregatesFilter
  _count: db_NestedIntFilter
  _min: db_NestedBoolFilter
  _max: db_NestedBoolFilter
}

input db_BoolWithAggregatesFilter {
  equals: Boolean
  not: db_NestedBoolWithAggregatesFilter
  _count: db_NestedIntFilter
  _min: db_NestedBoolFilter
  _max: db_NestedBoolFilter
}

input db_PostScalarWhereWithAggregatesInput {
  AND: db_PostScalarWhereWithAggregatesInput
  OR: [db_PostScalarWhereWithAggregatesInput]
  NOT: db_PostScalarWhereWithAggregatesInput
  id: db_StringWithAggregatesFilter
  title: db_StringWithAggregatesFilter
  content: db_JsonNullableWithAggregatesFilter
  published: db_BoolWithAggregatesFilter
  createdAt: db_DateTimeWithAggregatesFilter
  updatedAt: db_DateTimeWithAggregatesFilter
  authorId: db_StringWithAggregatesFilter
}

type db_PostGroupByOutputType {
  id: String!
  title: String!
  content: JSON
  published: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  authorId: String!
  _count: db_PostCountAggregateOutputType
  _min: db_PostMinAggregateOutputType
  _max: db_PostMaxAggregateOutputType
  _join: Query!
}

type db_TodoCountAggregateOutputType {
  id: Int!
  text: Int!
  isCompleted: Int!
  createdAt: Int!
  updatedAt: Int!
  userId: Int!
  _all: Int!
  _join: Query!
}

type db_TodoMinAggregateOutputType {
  id: String
  text: String
  isCompleted: Boolean
  createdAt: DateTime
  updatedAt: DateTime
  userId: String
  _join: Query!
}

type db_TodoMaxAggregateOutputType {
  id: String
  text: String
  isCompleted: Boolean
  createdAt: DateTime
  updatedAt: DateTime
  userId: String
  _join: Query!
}

type db_AggregateTodo {
  _count: db_TodoCountAggregateOutputType
  _min: db_TodoMinAggregateOutputType
  _max: db_TodoMaxAggregateOutputType
  _join: Query!
}

input db_TodoCountOrderByAggregateInput {
  id: db_SortOrder
  text: db_SortOrder
  isCompleted: db_SortOrder
  createdAt: db_SortOrder
  updatedAt: db_SortOrder
  userId: db_SortOrder
}

input db_TodoMaxOrderByAggregateInput {
  id: db_SortOrder
  text: db_SortOrder
  isCompleted: db_SortOrder
  createdAt: db_SortOrder
  updatedAt: db_SortOrder
  userId: db_SortOrder
}

input db_TodoMinOrderByAggregateInput {
  id: db_SortOrder
  text: db_SortOrder
  isCompleted: db_SortOrder
  createdAt: db_SortOrder
  updatedAt: db_SortOrder
  userId: db_SortOrder
}

input db_TodoOrderByWithAggregationInput {
  id: db_SortOrder
  text: db_SortOrder
  isCompleted: db_SortOrder
  createdAt: db_SortOrder
  updatedAt: db_SortOrder
  userId: db_SortOrder
  _count: db_TodoCountOrderByAggregateInput
  _max: db_TodoMaxOrderByAggregateInput
  _min: db_TodoMinOrderByAggregateInput
}

input db_TodoScalarWhereWithAggregatesInput {
  AND: db_TodoScalarWhereWithAggregatesInput
  OR: [db_TodoScalarWhereWithAggregatesInput]
  NOT: db_TodoScalarWhereWithAggregatesInput
  id: db_StringWithAggregatesFilter
  text: db_StringWithAggregatesFilter
  isCompleted: db_BoolWithAggregatesFilter
  createdAt: db_DateTimeWithAggregatesFilter
  updatedAt: db_DateTimeWithAggregatesFilter
  userId: db_StringWithAggregatesFilter
}

type db_TodoGroupByOutputType {
  id: String!
  text: String!
  isCompleted: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  userId: String!
  _count: db_TodoCountAggregateOutputType
  _min: db_TodoMinAggregateOutputType
  _max: db_TodoMaxAggregateOutputType
  _join: Query!
}

input db_SessionCreateWithoutUserInput {
  id: String
  sessionToken: String!
  expires: DateTime!
}

input db_SessionCreateOrConnectWithoutUserInput {
  where: db_SessionWhereUniqueInput!
  create: db_SessionCreateWithoutUserInput!
}

input db_SessionCreateManyUserInput {
  id: String
  sessionToken: String!
  expires: DateTime!
}

input db_SessionCreateManyUserInputEnvelope {
  data: db_SessionCreateManyUserInput!
  skipDuplicates: Boolean
}

input db_SessionCreateNestedManyWithoutUserInput {
  create: db_SessionCreateWithoutUserInput
  connectOrCreate: db_SessionCreateOrConnectWithoutUserInput
  createMany: db_SessionCreateManyUserInputEnvelope
  connect: db_SessionWhereUniqueInput
}

enum db_NullableJsonNullValueInput {
  DbNull
  JsonNull
}

input db_PostCreateWithoutAuthorInput {
  id: String
  title: String!
  content: db_NullableJsonNullValueInput
  published: Boolean
  createdAt: DateTime
  updatedAt: DateTime
}

input db_PostCreateOrConnectWithoutAuthorInput {
  where: db_PostWhereUniqueInput!
  create: db_PostCreateWithoutAuthorInput!
}

input db_PostCreateManyAuthorInput {
  id: String
  title: String!
  content: db_NullableJsonNullValueInput
  published: Boolean
  createdAt: DateTime
  updatedAt: DateTime
}

input db_PostCreateManyAuthorInputEnvelope {
  data: db_PostCreateManyAuthorInput!
  skipDuplicates: Boolean
}

input db_PostCreateNestedManyWithoutAuthorInput {
  create: db_PostCreateWithoutAuthorInput
  connectOrCreate: db_PostCreateOrConnectWithoutAuthorInput
  createMany: db_PostCreateManyAuthorInputEnvelope
  connect: db_PostWhereUniqueInput
}

input db_TodoCreateWithoutUserInput {
  id: String
  text: String!
  isCompleted: Boolean
  createdAt: DateTime
  updatedAt: DateTime
}

input db_TodoCreateOrConnectWithoutUserInput {
  where: db_TodoWhereUniqueInput!
  create: db_TodoCreateWithoutUserInput!
}

input db_TodoCreateManyUserInput {
  id: String
  text: String!
  isCompleted: Boolean
  createdAt: DateTime
  updatedAt: DateTime
}

input db_TodoCreateManyUserInputEnvelope {
  data: db_TodoCreateManyUserInput!
  skipDuplicates: Boolean
}

input db_TodoCreateNestedManyWithoutUserInput {
  create: db_TodoCreateWithoutUserInput
  connectOrCreate: db_TodoCreateOrConnectWithoutUserInput
  createMany: db_TodoCreateManyUserInputEnvelope
  connect: db_TodoWhereUniqueInput
}

input db_UserCreateWithoutAccountsInput {
  id: String
  name: String
  email: String
  emailVerified: DateTime
  image: String
  createdAt: DateTime
  updatedAt: DateTime
  stripeCustomerId: String
  stripeSubscriptionId: String
  stripePriceId: String
  stripeCurrentPeriodEnd: DateTime
  sessions: db_SessionCreateNestedManyWithoutUserInput
  Post: db_PostCreateNestedManyWithoutAuthorInput
  Todo: db_TodoCreateNestedManyWithoutUserInput
}

input db_UserCreateOrConnectWithoutAccountsInput {
  where: db_UserWhereUniqueInput!
  create: db_UserCreateWithoutAccountsInput!
}

input db_UserCreateNestedOneWithoutAccountsInput {
  create: db_UserCreateWithoutAccountsInput
  connectOrCreate: db_UserCreateOrConnectWithoutAccountsInput
  connect: db_UserWhereUniqueInput
}

input db_AccountCreateInput {
  id: String
  type: String!
  provider: String!
  providerAccountId: String!
  refresh_token: String
  access_token: String
  expires_at: Int
  token_type: String
  scope: String
  id_token: String
  session_state: String
  createdAt: DateTime
  updatedAt: DateTime
  user: db_UserCreateNestedOneWithoutAccountsInput!
}

input db_StringFieldUpdateOperationsInput {
  set: String
}

input db_NullableStringFieldUpdateOperationsInput {
  set: String
}

input db_NullableIntFieldUpdateOperationsInput {
  set: Int
  increment: Int
  decrement: Int
  multiply: Int
  divide: Int
}

input db_DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input db_NullableDateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input db_SessionUpdateWithoutUserInput {
  id: db_StringFieldUpdateOperationsInput
  sessionToken: db_StringFieldUpdateOperationsInput
  expires: db_DateTimeFieldUpdateOperationsInput
}

input db_SessionUpsertWithWhereUniqueWithoutUserInput {
  where: db_SessionWhereUniqueInput!
  update: db_SessionUpdateWithoutUserInput!
  create: db_SessionCreateWithoutUserInput!
}

input db_SessionUpdateWithWhereUniqueWithoutUserInput {
  where: db_SessionWhereUniqueInput!
  data: db_SessionUpdateWithoutUserInput!
}

input db_SessionScalarWhereInput {
  AND: db_SessionScalarWhereInput
  OR: [db_SessionScalarWhereInput]
  NOT: db_SessionScalarWhereInput
  id: db_StringFilter
  sessionToken: db_StringFilter
  userId: db_StringFilter
  expires: db_DateTimeFilter
}

input db_SessionUpdateManyMutationInput {
  id: db_StringFieldUpdateOperationsInput
  sessionToken: db_StringFieldUpdateOperationsInput
  expires: db_DateTimeFieldUpdateOperationsInput
}

input db_SessionUpdateManyWithWhereWithoutUserInput {
  where: db_SessionScalarWhereInput!
  data: db_SessionUpdateManyMutationInput!
}

input db_SessionUpdateManyWithoutUserNestedInput {
  create: db_SessionCreateWithoutUserInput
  connectOrCreate: db_SessionCreateOrConnectWithoutUserInput
  upsert: db_SessionUpsertWithWhereUniqueWithoutUserInput
  createMany: db_SessionCreateManyUserInputEnvelope
  set: db_SessionWhereUniqueInput
  disconnect: db_SessionWhereUniqueInput
  delete: db_SessionWhereUniqueInput
  connect: db_SessionWhereUniqueInput
  update: db_SessionUpdateWithWhereUniqueWithoutUserInput
  updateMany: db_SessionUpdateManyWithWhereWithoutUserInput
  deleteMany: db_SessionScalarWhereInput
}

input db_BoolFieldUpdateOperationsInput {
  set: Boolean
}

input db_PostUpdateWithoutAuthorInput {
  id: db_StringFieldUpdateOperationsInput
  title: db_StringFieldUpdateOperationsInput
  content: db_NullableJsonNullValueInput
  published: db_BoolFieldUpdateOperationsInput
  createdAt: db_DateTimeFieldUpdateOperationsInput
  updatedAt: db_DateTimeFieldUpdateOperationsInput
}

input db_PostUpsertWithWhereUniqueWithoutAuthorInput {
  where: db_PostWhereUniqueInput!
  update: db_PostUpdateWithoutAuthorInput!
  create: db_PostCreateWithoutAuthorInput!
}

input db_PostUpdateWithWhereUniqueWithoutAuthorInput {
  where: db_PostWhereUniqueInput!
  data: db_PostUpdateWithoutAuthorInput!
}

input db_PostScalarWhereInput {
  AND: db_PostScalarWhereInput
  OR: [db_PostScalarWhereInput]
  NOT: db_PostScalarWhereInput
  id: db_StringFilter
  title: db_StringFilter
  content: db_JsonNullableFilter
  published: db_BoolFilter
  createdAt: db_DateTimeFilter
  updatedAt: db_DateTimeFilter
  authorId: db_StringFilter
}

input db_PostUpdateManyMutationInput {
  id: db_StringFieldUpdateOperationsInput
  title: db_StringFieldUpdateOperationsInput
  content: db_NullableJsonNullValueInput
  published: db_BoolFieldUpdateOperationsInput
  createdAt: db_DateTimeFieldUpdateOperationsInput
  updatedAt: db_DateTimeFieldUpdateOperationsInput
}

input db_PostUpdateManyWithWhereWithoutAuthorInput {
  where: db_PostScalarWhereInput!
  data: db_PostUpdateManyMutationInput!
}

input db_PostUpdateManyWithoutAuthorNestedInput {
  create: db_PostCreateWithoutAuthorInput
  connectOrCreate: db_PostCreateOrConnectWithoutAuthorInput
  upsert: db_PostUpsertWithWhereUniqueWithoutAuthorInput
  createMany: db_PostCreateManyAuthorInputEnvelope
  set: db_PostWhereUniqueInput
  disconnect: db_PostWhereUniqueInput
  delete: db_PostWhereUniqueInput
  connect: db_PostWhereUniqueInput
  update: db_PostUpdateWithWhereUniqueWithoutAuthorInput
  updateMany: db_PostUpdateManyWithWhereWithoutAuthorInput
  deleteMany: db_PostScalarWhereInput
}

input db_TodoUpdateWithoutUserInput {
  id: db_StringFieldUpdateOperationsInput
  text: db_StringFieldUpdateOperationsInput
  isCompleted: db_BoolFieldUpdateOperationsInput
  createdAt: db_DateTimeFieldUpdateOperationsInput
  updatedAt: db_DateTimeFieldUpdateOperationsInput
}

input db_TodoUpsertWithWhereUniqueWithoutUserInput {
  where: db_TodoWhereUniqueInput!
  update: db_TodoUpdateWithoutUserInput!
  create: db_TodoCreateWithoutUserInput!
}

input db_TodoUpdateWithWhereUniqueWithoutUserInput {
  where: db_TodoWhereUniqueInput!
  data: db_TodoUpdateWithoutUserInput!
}

input db_TodoScalarWhereInput {
  AND: db_TodoScalarWhereInput
  OR: [db_TodoScalarWhereInput]
  NOT: db_TodoScalarWhereInput
  id: db_StringFilter
  text: db_StringFilter
  isCompleted: db_BoolFilter
  createdAt: db_DateTimeFilter
  updatedAt: db_DateTimeFilter
  userId: db_StringFilter
}

input db_TodoUpdateManyMutationInput {
  id: db_StringFieldUpdateOperationsInput
  text: db_StringFieldUpdateOperationsInput
  isCompleted: db_BoolFieldUpdateOperationsInput
  createdAt: db_DateTimeFieldUpdateOperationsInput
  updatedAt: db_DateTimeFieldUpdateOperationsInput
}

input db_TodoUpdateManyWithWhereWithoutUserInput {
  where: db_TodoScalarWhereInput!
  data: db_TodoUpdateManyMutationInput!
}

input db_TodoUpdateManyWithoutUserNestedInput {
  create: db_TodoCreateWithoutUserInput
  connectOrCreate: db_TodoCreateOrConnectWithoutUserInput
  upsert: db_TodoUpsertWithWhereUniqueWithoutUserInput
  createMany: db_TodoCreateManyUserInputEnvelope
  set: db_TodoWhereUniqueInput
  disconnect: db_TodoWhereUniqueInput
  delete: db_TodoWhereUniqueInput
  connect: db_TodoWhereUniqueInput
  update: db_TodoUpdateWithWhereUniqueWithoutUserInput
  updateMany: db_TodoUpdateManyWithWhereWithoutUserInput
  deleteMany: db_TodoScalarWhereInput
}

input db_UserUpdateWithoutAccountsInput {
  id: db_StringFieldUpdateOperationsInput
  name: db_NullableStringFieldUpdateOperationsInput
  email: db_NullableStringFieldUpdateOperationsInput
  emailVerified: db_NullableDateTimeFieldUpdateOperationsInput
  image: db_NullableStringFieldUpdateOperationsInput
  createdAt: db_DateTimeFieldUpdateOperationsInput
  updatedAt: db_DateTimeFieldUpdateOperationsInput
  stripeCustomerId: db_NullableStringFieldUpdateOperationsInput
  stripeSubscriptionId: db_NullableStringFieldUpdateOperationsInput
  stripePriceId: db_NullableStringFieldUpdateOperationsInput
  stripeCurrentPeriodEnd: db_NullableDateTimeFieldUpdateOperationsInput
  sessions: db_SessionUpdateManyWithoutUserNestedInput
  Post: db_PostUpdateManyWithoutAuthorNestedInput
  Todo: db_TodoUpdateManyWithoutUserNestedInput
}

input db_UserUpsertWithoutAccountsInput {
  update: db_UserUpdateWithoutAccountsInput!
  create: db_UserCreateWithoutAccountsInput!
}

input db_UserUpdateOneRequiredWithoutAccountsNestedInput {
  create: db_UserCreateWithoutAccountsInput
  connectOrCreate: db_UserCreateOrConnectWithoutAccountsInput
  upsert: db_UserUpsertWithoutAccountsInput
  connect: db_UserWhereUniqueInput
  update: db_UserUpdateWithoutAccountsInput
}

input db_AccountUpdateInput {
  id: db_StringFieldUpdateOperationsInput
  type: db_StringFieldUpdateOperationsInput
  provider: db_StringFieldUpdateOperationsInput
  providerAccountId: db_StringFieldUpdateOperationsInput
  refresh_token: db_NullableStringFieldUpdateOperationsInput
  access_token: db_NullableStringFieldUpdateOperationsInput
  expires_at: db_NullableIntFieldUpdateOperationsInput
  token_type: db_NullableStringFieldUpdateOperationsInput
  scope: db_NullableStringFieldUpdateOperationsInput
  id_token: db_NullableStringFieldUpdateOperationsInput
  session_state: db_NullableStringFieldUpdateOperationsInput
  createdAt: db_DateTimeFieldUpdateOperationsInput
  updatedAt: db_DateTimeFieldUpdateOperationsInput
  user: db_UserUpdateOneRequiredWithoutAccountsNestedInput
}

input db_AccountCreateManyInput {
  id: String
  userId: String!
  type: String!
  provider: String!
  providerAccountId: String!
  refresh_token: String
  access_token: String
  expires_at: Int
  token_type: String
  scope: String
  id_token: String
  session_state: String
  createdAt: DateTime
  updatedAt: DateTime
}

type db_AffectedRowsOutput {
  count: Int!
  _join: Query!
}

input db_AccountUpdateManyMutationInput {
  id: db_StringFieldUpdateOperationsInput
  type: db_StringFieldUpdateOperationsInput
  provider: db_StringFieldUpdateOperationsInput
  providerAccountId: db_StringFieldUpdateOperationsInput
  refresh_token: db_NullableStringFieldUpdateOperationsInput
  access_token: db_NullableStringFieldUpdateOperationsInput
  expires_at: db_NullableIntFieldUpdateOperationsInput
  token_type: db_NullableStringFieldUpdateOperationsInput
  scope: db_NullableStringFieldUpdateOperationsInput
  id_token: db_NullableStringFieldUpdateOperationsInput
  session_state: db_NullableStringFieldUpdateOperationsInput
  createdAt: db_DateTimeFieldUpdateOperationsInput
  updatedAt: db_DateTimeFieldUpdateOperationsInput
}

input db_AccountCreateWithoutUserInput {
  id: String
  type: String!
  provider: String!
  providerAccountId: String!
  refresh_token: String
  access_token: String
  expires_at: Int
  token_type: String
  scope: String
  id_token: String
  session_state: String
  createdAt: DateTime
  updatedAt: DateTime
}

input db_AccountCreateOrConnectWithoutUserInput {
  where: db_AccountWhereUniqueInput!
  create: db_AccountCreateWithoutUserInput!
}

input db_AccountCreateManyUserInput {
  id: String
  type: String!
  provider: String!
  providerAccountId: String!
  refresh_token: String
  access_token: String
  expires_at: Int
  token_type: String
  scope: String
  id_token: String
  session_state: String
  createdAt: DateTime
  updatedAt: DateTime
}

input db_AccountCreateManyUserInputEnvelope {
  data: db_AccountCreateManyUserInput!
  skipDuplicates: Boolean
}

input db_AccountCreateNestedManyWithoutUserInput {
  create: db_AccountCreateWithoutUserInput
  connectOrCreate: db_AccountCreateOrConnectWithoutUserInput
  createMany: db_AccountCreateManyUserInputEnvelope
  connect: db_AccountWhereUniqueInput
}

input db_UserCreateWithoutSessionsInput {
  id: String
  name: String
  email: String
  emailVerified: DateTime
  image: String
  createdAt: DateTime
  updatedAt: DateTime
  stripeCustomerId: String
  stripeSubscriptionId: String
  stripePriceId: String
  stripeCurrentPeriodEnd: DateTime
  accounts: db_AccountCreateNestedManyWithoutUserInput
  Post: db_PostCreateNestedManyWithoutAuthorInput
  Todo: db_TodoCreateNestedManyWithoutUserInput
}

input db_UserCreateOrConnectWithoutSessionsInput {
  where: db_UserWhereUniqueInput!
  create: db_UserCreateWithoutSessionsInput!
}

input db_UserCreateNestedOneWithoutSessionsInput {
  create: db_UserCreateWithoutSessionsInput
  connectOrCreate: db_UserCreateOrConnectWithoutSessionsInput
  connect: db_UserWhereUniqueInput
}

input db_SessionCreateInput {
  id: String
  sessionToken: String!
  expires: DateTime!
  user: db_UserCreateNestedOneWithoutSessionsInput!
}

input db_AccountUpdateWithoutUserInput {
  id: db_StringFieldUpdateOperationsInput
  type: db_StringFieldUpdateOperationsInput
  provider: db_StringFieldUpdateOperationsInput
  providerAccountId: db_StringFieldUpdateOperationsInput
  refresh_token: db_NullableStringFieldUpdateOperationsInput
  access_token: db_NullableStringFieldUpdateOperationsInput
  expires_at: db_NullableIntFieldUpdateOperationsInput
  token_type: db_NullableStringFieldUpdateOperationsInput
  scope: db_NullableStringFieldUpdateOperationsInput
  id_token: db_NullableStringFieldUpdateOperationsInput
  session_state: db_NullableStringFieldUpdateOperationsInput
  createdAt: db_DateTimeFieldUpdateOperationsInput
  updatedAt: db_DateTimeFieldUpdateOperationsInput
}

input db_AccountUpsertWithWhereUniqueWithoutUserInput {
  where: db_AccountWhereUniqueInput!
  update: db_AccountUpdateWithoutUserInput!
  create: db_AccountCreateWithoutUserInput!
}

input db_AccountUpdateWithWhereUniqueWithoutUserInput {
  where: db_AccountWhereUniqueInput!
  data: db_AccountUpdateWithoutUserInput!
}

input db_AccountScalarWhereInput {
  AND: db_AccountScalarWhereInput
  OR: [db_AccountScalarWhereInput]
  NOT: db_AccountScalarWhereInput
  id: db_StringFilter
  userId: db_StringFilter
  type: db_StringFilter
  provider: db_StringFilter
  providerAccountId: db_StringFilter
  refresh_token: db_StringNullableFilter
  access_token: db_StringNullableFilter
  expires_at: db_IntNullableFilter
  token_type: db_StringNullableFilter
  scope: db_StringNullableFilter
  id_token: db_StringNullableFilter
  session_state: db_StringNullableFilter
  createdAt: db_DateTimeFilter
  updatedAt: db_DateTimeFilter
}

input db_AccountUpdateManyWithWhereWithoutUserInput {
  where: db_AccountScalarWhereInput!
  data: db_AccountUpdateManyMutationInput!
}

input db_AccountUpdateManyWithoutUserNestedInput {
  create: db_AccountCreateWithoutUserInput
  connectOrCreate: db_AccountCreateOrConnectWithoutUserInput
  upsert: db_AccountUpsertWithWhereUniqueWithoutUserInput
  createMany: db_AccountCreateManyUserInputEnvelope
  set: db_AccountWhereUniqueInput
  disconnect: db_AccountWhereUniqueInput
  delete: db_AccountWhereUniqueInput
  connect: db_AccountWhereUniqueInput
  update: db_AccountUpdateWithWhereUniqueWithoutUserInput
  updateMany: db_AccountUpdateManyWithWhereWithoutUserInput
  deleteMany: db_AccountScalarWhereInput
}

input db_UserUpdateWithoutSessionsInput {
  id: db_StringFieldUpdateOperationsInput
  name: db_NullableStringFieldUpdateOperationsInput
  email: db_NullableStringFieldUpdateOperationsInput
  emailVerified: db_NullableDateTimeFieldUpdateOperationsInput
  image: db_NullableStringFieldUpdateOperationsInput
  createdAt: db_DateTimeFieldUpdateOperationsInput
  updatedAt: db_DateTimeFieldUpdateOperationsInput
  stripeCustomerId: db_NullableStringFieldUpdateOperationsInput
  stripeSubscriptionId: db_NullableStringFieldUpdateOperationsInput
  stripePriceId: db_NullableStringFieldUpdateOperationsInput
  stripeCurrentPeriodEnd: db_NullableDateTimeFieldUpdateOperationsInput
  accounts: db_AccountUpdateManyWithoutUserNestedInput
  Post: db_PostUpdateManyWithoutAuthorNestedInput
  Todo: db_TodoUpdateManyWithoutUserNestedInput
}

input db_UserUpsertWithoutSessionsInput {
  update: db_UserUpdateWithoutSessionsInput!
  create: db_UserCreateWithoutSessionsInput!
}

input db_UserUpdateOneRequiredWithoutSessionsNestedInput {
  create: db_UserCreateWithoutSessionsInput
  connectOrCreate: db_UserCreateOrConnectWithoutSessionsInput
  upsert: db_UserUpsertWithoutSessionsInput
  connect: db_UserWhereUniqueInput
  update: db_UserUpdateWithoutSessionsInput
}

input db_SessionUpdateInput {
  id: db_StringFieldUpdateOperationsInput
  sessionToken: db_StringFieldUpdateOperationsInput
  expires: db_DateTimeFieldUpdateOperationsInput
  user: db_UserUpdateOneRequiredWithoutSessionsNestedInput
}

input db_SessionCreateManyInput {
  id: String
  sessionToken: String!
  userId: String!
  expires: DateTime!
}

input db_UserCreateInput {
  id: String
  name: String
  email: String
  emailVerified: DateTime
  image: String
  createdAt: DateTime
  updatedAt: DateTime
  stripeCustomerId: String
  stripeSubscriptionId: String
  stripePriceId: String
  stripeCurrentPeriodEnd: DateTime
  accounts: db_AccountCreateNestedManyWithoutUserInput
  sessions: db_SessionCreateNestedManyWithoutUserInput
  Post: db_PostCreateNestedManyWithoutAuthorInput
  Todo: db_TodoCreateNestedManyWithoutUserInput
}

input db_UserUpdateInput {
  id: db_StringFieldUpdateOperationsInput
  name: db_NullableStringFieldUpdateOperationsInput
  email: db_NullableStringFieldUpdateOperationsInput
  emailVerified: db_NullableDateTimeFieldUpdateOperationsInput
  image: db_NullableStringFieldUpdateOperationsInput
  createdAt: db_DateTimeFieldUpdateOperationsInput
  updatedAt: db_DateTimeFieldUpdateOperationsInput
  stripeCustomerId: db_NullableStringFieldUpdateOperationsInput
  stripeSubscriptionId: db_NullableStringFieldUpdateOperationsInput
  stripePriceId: db_NullableStringFieldUpdateOperationsInput
  stripeCurrentPeriodEnd: db_NullableDateTimeFieldUpdateOperationsInput
  accounts: db_AccountUpdateManyWithoutUserNestedInput
  sessions: db_SessionUpdateManyWithoutUserNestedInput
  Post: db_PostUpdateManyWithoutAuthorNestedInput
  Todo: db_TodoUpdateManyWithoutUserNestedInput
}

input db_UserCreateManyInput {
  id: String
  name: String
  email: String
  emailVerified: DateTime
  image: String
  createdAt: DateTime
  updatedAt: DateTime
  stripeCustomerId: String
  stripeSubscriptionId: String
  stripePriceId: String
  stripeCurrentPeriodEnd: DateTime
}

input db_UserUpdateManyMutationInput {
  id: db_StringFieldUpdateOperationsInput
  name: db_NullableStringFieldUpdateOperationsInput
  email: db_NullableStringFieldUpdateOperationsInput
  emailVerified: db_NullableDateTimeFieldUpdateOperationsInput
  image: db_NullableStringFieldUpdateOperationsInput
  createdAt: db_DateTimeFieldUpdateOperationsInput
  updatedAt: db_DateTimeFieldUpdateOperationsInput
  stripeCustomerId: db_NullableStringFieldUpdateOperationsInput
  stripeSubscriptionId: db_NullableStringFieldUpdateOperationsInput
  stripePriceId: db_NullableStringFieldUpdateOperationsInput
  stripeCurrentPeriodEnd: db_NullableDateTimeFieldUpdateOperationsInput
}

input db_VerificationTokenCreateInput {
  identifier: String!
  token: String!
  expires: DateTime!
}

input db_VerificationTokenUpdateInput {
  identifier: db_StringFieldUpdateOperationsInput
  token: db_StringFieldUpdateOperationsInput
  expires: db_DateTimeFieldUpdateOperationsInput
}

input db_VerificationTokenCreateManyInput {
  identifier: String!
  token: String!
  expires: DateTime!
}

input db_VerificationTokenUpdateManyMutationInput {
  identifier: db_StringFieldUpdateOperationsInput
  token: db_StringFieldUpdateOperationsInput
  expires: db_DateTimeFieldUpdateOperationsInput
}

input db_UserCreateWithoutPostInput {
  id: String
  name: String
  email: String
  emailVerified: DateTime
  image: String
  createdAt: DateTime
  updatedAt: DateTime
  stripeCustomerId: String
  stripeSubscriptionId: String
  stripePriceId: String
  stripeCurrentPeriodEnd: DateTime
  accounts: db_AccountCreateNestedManyWithoutUserInput
  sessions: db_SessionCreateNestedManyWithoutUserInput
  Todo: db_TodoCreateNestedManyWithoutUserInput
}

input db_UserCreateOrConnectWithoutPostInput {
  where: db_UserWhereUniqueInput!
  create: db_UserCreateWithoutPostInput!
}

input db_UserCreateNestedOneWithoutPostInput {
  create: db_UserCreateWithoutPostInput
  connectOrCreate: db_UserCreateOrConnectWithoutPostInput
  connect: db_UserWhereUniqueInput
}

input db_PostCreateInput {
  id: String
  title: String!
  content: db_NullableJsonNullValueInput
  published: Boolean
  createdAt: DateTime
  updatedAt: DateTime
  author: db_UserCreateNestedOneWithoutPostInput!
}

input db_UserUpdateWithoutPostInput {
  id: db_StringFieldUpdateOperationsInput
  name: db_NullableStringFieldUpdateOperationsInput
  email: db_NullableStringFieldUpdateOperationsInput
  emailVerified: db_NullableDateTimeFieldUpdateOperationsInput
  image: db_NullableStringFieldUpdateOperationsInput
  createdAt: db_DateTimeFieldUpdateOperationsInput
  updatedAt: db_DateTimeFieldUpdateOperationsInput
  stripeCustomerId: db_NullableStringFieldUpdateOperationsInput
  stripeSubscriptionId: db_NullableStringFieldUpdateOperationsInput
  stripePriceId: db_NullableStringFieldUpdateOperationsInput
  stripeCurrentPeriodEnd: db_NullableDateTimeFieldUpdateOperationsInput
  accounts: db_AccountUpdateManyWithoutUserNestedInput
  sessions: db_SessionUpdateManyWithoutUserNestedInput
  Todo: db_TodoUpdateManyWithoutUserNestedInput
}

input db_UserUpsertWithoutPostInput {
  update: db_UserUpdateWithoutPostInput!
  create: db_UserCreateWithoutPostInput!
}

input db_UserUpdateOneRequiredWithoutPostNestedInput {
  create: db_UserCreateWithoutPostInput
  connectOrCreate: db_UserCreateOrConnectWithoutPostInput
  upsert: db_UserUpsertWithoutPostInput
  connect: db_UserWhereUniqueInput
  update: db_UserUpdateWithoutPostInput
}

input db_PostUpdateInput {
  id: db_StringFieldUpdateOperationsInput
  title: db_StringFieldUpdateOperationsInput
  content: db_NullableJsonNullValueInput
  published: db_BoolFieldUpdateOperationsInput
  createdAt: db_DateTimeFieldUpdateOperationsInput
  updatedAt: db_DateTimeFieldUpdateOperationsInput
  author: db_UserUpdateOneRequiredWithoutPostNestedInput
}

input db_PostCreateManyInput {
  id: String
  title: String!
  content: db_NullableJsonNullValueInput
  published: Boolean
  createdAt: DateTime
  updatedAt: DateTime
  authorId: String!
}

input db_UserCreateWithoutTodoInput {
  id: String
  name: String
  email: String
  emailVerified: DateTime
  image: String
  createdAt: DateTime
  updatedAt: DateTime
  stripeCustomerId: String
  stripeSubscriptionId: String
  stripePriceId: String
  stripeCurrentPeriodEnd: DateTime
  accounts: db_AccountCreateNestedManyWithoutUserInput
  sessions: db_SessionCreateNestedManyWithoutUserInput
  Post: db_PostCreateNestedManyWithoutAuthorInput
}

input db_UserCreateOrConnectWithoutTodoInput {
  where: db_UserWhereUniqueInput!
  create: db_UserCreateWithoutTodoInput!
}

input db_UserCreateNestedOneWithoutTodoInput {
  create: db_UserCreateWithoutTodoInput
  connectOrCreate: db_UserCreateOrConnectWithoutTodoInput
  connect: db_UserWhereUniqueInput
}

input db_TodoCreateInput {
  id: String
  text: String!
  isCompleted: Boolean
  createdAt: DateTime
  updatedAt: DateTime
  user: db_UserCreateNestedOneWithoutTodoInput!
}

input db_UserUpdateWithoutTodoInput {
  id: db_StringFieldUpdateOperationsInput
  name: db_NullableStringFieldUpdateOperationsInput
  email: db_NullableStringFieldUpdateOperationsInput
  emailVerified: db_NullableDateTimeFieldUpdateOperationsInput
  image: db_NullableStringFieldUpdateOperationsInput
  createdAt: db_DateTimeFieldUpdateOperationsInput
  updatedAt: db_DateTimeFieldUpdateOperationsInput
  stripeCustomerId: db_NullableStringFieldUpdateOperationsInput
  stripeSubscriptionId: db_NullableStringFieldUpdateOperationsInput
  stripePriceId: db_NullableStringFieldUpdateOperationsInput
  stripeCurrentPeriodEnd: db_NullableDateTimeFieldUpdateOperationsInput
  accounts: db_AccountUpdateManyWithoutUserNestedInput
  sessions: db_SessionUpdateManyWithoutUserNestedInput
  Post: db_PostUpdateManyWithoutAuthorNestedInput
}

input db_UserUpsertWithoutTodoInput {
  update: db_UserUpdateWithoutTodoInput!
  create: db_UserCreateWithoutTodoInput!
}

input db_UserUpdateOneRequiredWithoutTodoNestedInput {
  create: db_UserCreateWithoutTodoInput
  connectOrCreate: db_UserCreateOrConnectWithoutTodoInput
  upsert: db_UserUpsertWithoutTodoInput
  connect: db_UserWhereUniqueInput
  update: db_UserUpdateWithoutTodoInput
}

input db_TodoUpdateInput {
  id: db_StringFieldUpdateOperationsInput
  text: db_StringFieldUpdateOperationsInput
  isCompleted: db_BoolFieldUpdateOperationsInput
  createdAt: db_DateTimeFieldUpdateOperationsInput
  updatedAt: db_DateTimeFieldUpdateOperationsInput
  user: db_UserUpdateOneRequiredWithoutTodoNestedInput
}

input db_TodoCreateManyInput {
  id: String
  text: String!
  isCompleted: Boolean
  createdAt: DateTime
  updatedAt: DateTime
  userId: String!
}

type Mutation {
  db_createOneAccount(data: db_AccountCreateInput!): db_Account
  db_upsertOneAccount(where: db_AccountWhereUniqueInput!, create: db_AccountCreateInput!, update: db_AccountUpdateInput!): db_Account
  db_createManyAccount(data: [db_AccountCreateManyInput]!, skipDuplicates: Boolean): db_AffectedRowsOutput
  db_deleteOneAccount(where: db_AccountWhereUniqueInput!): db_Account
  db_updateOneAccount(data: db_AccountUpdateInput!, where: db_AccountWhereUniqueInput!): db_Account
  db_updateManyAccount(data: db_AccountUpdateManyMutationInput!, where: db_AccountWhereInput): db_AffectedRowsOutput
  db_deleteManyAccount(where: db_AccountWhereInput): db_AffectedRowsOutput
  db_createOneSession(data: db_SessionCreateInput!): db_Session
  db_upsertOneSession(where: db_SessionWhereUniqueInput!, create: db_SessionCreateInput!, update: db_SessionUpdateInput!): db_Session
  db_createManySession(data: [db_SessionCreateManyInput]!, skipDuplicates: Boolean): db_AffectedRowsOutput
  db_deleteOneSession(where: db_SessionWhereUniqueInput!): db_Session
  db_updateOneSession(data: db_SessionUpdateInput!, where: db_SessionWhereUniqueInput!): db_Session
  db_updateManySession(data: db_SessionUpdateManyMutationInput!, where: db_SessionWhereInput): db_AffectedRowsOutput
  db_deleteManySession(where: db_SessionWhereInput): db_AffectedRowsOutput
  db_createOneUser(data: db_UserCreateInput!): db_User
  db_upsertOneUser(where: db_UserWhereUniqueInput!, create: db_UserCreateInput!, update: db_UserUpdateInput!): db_User
  db_createManyUser(data: [db_UserCreateManyInput]!, skipDuplicates: Boolean): db_AffectedRowsOutput
  db_deleteOneUser(where: db_UserWhereUniqueInput!): db_User
  db_updateOneUser(data: db_UserUpdateInput!, where: db_UserWhereUniqueInput!): db_User
  db_updateManyUser(data: db_UserUpdateManyMutationInput!, where: db_UserWhereInput): db_AffectedRowsOutput
  db_deleteManyUser(where: db_UserWhereInput): db_AffectedRowsOutput
  db_createOneVerificationToken(data: db_VerificationTokenCreateInput!): db_VerificationToken
  db_upsertOneVerificationToken(where: db_VerificationTokenWhereUniqueInput!, create: db_VerificationTokenCreateInput!, update: db_VerificationTokenUpdateInput!): db_VerificationToken
  db_createManyVerificationToken(data: [db_VerificationTokenCreateManyInput]!, skipDuplicates: Boolean): db_AffectedRowsOutput
  db_deleteOneVerificationToken(where: db_VerificationTokenWhereUniqueInput!): db_VerificationToken
  db_updateOneVerificationToken(data: db_VerificationTokenUpdateInput!, where: db_VerificationTokenWhereUniqueInput!): db_VerificationToken
  db_updateManyVerificationToken(data: db_VerificationTokenUpdateManyMutationInput!, where: db_VerificationTokenWhereInput): db_AffectedRowsOutput
  db_deleteManyVerificationToken(where: db_VerificationTokenWhereInput): db_AffectedRowsOutput
  db_createOnePost(data: db_PostCreateInput!): db_Post
  db_upsertOnePost(where: db_PostWhereUniqueInput!, create: db_PostCreateInput!, update: db_PostUpdateInput!): db_Post
  db_createManyPost(data: [db_PostCreateManyInput]!, skipDuplicates: Boolean): db_AffectedRowsOutput
  db_deleteOnePost(where: db_PostWhereUniqueInput!): db_Post
  db_updateOnePost(data: db_PostUpdateInput!, where: db_PostWhereUniqueInput!): db_Post
  db_updateManyPost(data: db_PostUpdateManyMutationInput!, where: db_PostWhereInput): db_AffectedRowsOutput
  db_deleteManyPost(where: db_PostWhereInput): db_AffectedRowsOutput
  db_createOneTodo(data: db_TodoCreateInput!): db_Todo
  db_upsertOneTodo(where: db_TodoWhereUniqueInput!, create: db_TodoCreateInput!, update: db_TodoUpdateInput!): db_Todo
  db_createManyTodo(data: [db_TodoCreateManyInput]!, skipDuplicates: Boolean): db_AffectedRowsOutput
  db_deleteOneTodo(where: db_TodoWhereUniqueInput!): db_Todo
  db_updateOneTodo(data: db_TodoUpdateInput!, where: db_TodoWhereUniqueInput!): db_Todo
  db_updateManyTodo(data: db_TodoUpdateManyMutationInput!, where: db_TodoWhereInput): db_AffectedRowsOutput
  db_deleteManyTodo(where: db_TodoWhereInput): db_AffectedRowsOutput
  db_executeRaw(query: String!, parameters: [String]): Int!
}

scalar DateTime

scalar JSON

scalar UUID

scalar BigInt

scalar db_Bytes

type _Row {
  ID: ID!
  Int: Int!
  Float: Float!
  String: String!
  Boolean: Boolean!
  DateTime: DateTime!
  JSON: JSON!
  Object: _Row!
  Array: [_Row!]!
  OptionalID: ID
  OptionalInt: Int
  OptionalFloat: Float
  OptionalString: String
  OptionalBoolean: Boolean
  OptionalDateTime: DateTime
  OptionalJSON: JSON
  OptionalObject: _Row
  OptionalArray: [_Row!]
  _join: Query!
}

enum weather_CacheControlScope {
  PRIVATE
  PUBLIC
}

type weather_City {
  coord: weather_Coordinates
  country: String
  id: ID
  name: String
  weather: weather_Weather
  _join: Query!
}

type weather_Clouds {
  all: Int
  humidity: Int
  visibility: Int
  _join: Query!
}

input weather_ConfigInput {
  lang: weather_Language
  units: weather_Unit
}

type weather_Coordinates {
  lat: Float
  lon: Float
  _join: Query!
}

enum weather_Language {
  af
  al
  ar
  az
  bg
  ca
  cz
  da
  de
  el
  en
  es
  eu
  fa
  fi
  fr
  gl
  he
  hi
  hr
  hu
  id
  it
  ja
  kr
  la
  lt
  mk
  nl
  no
  pl
  pt
  pt_br
  ro
  ru
  se
  sk
  sl
  sp
  sr
  sv
  th
  tr
  ua
  uk
  vi
  zh_cn
  zh_tw
  zu
}

type weather_Summary {
  description: String
  icon: String
  title: String
  _join: Query!
}

type weather_Temperature {
  actual: Float
  feelsLike: Float
  max: Float
  min: Float
  _join: Query!
}

enum weather_Unit {
  imperial
  kelvin
  metric
}

"""The `Upload` scalar type represents a file upload."""
scalar weather_Upload

type weather_Weather {
  clouds: weather_Clouds
  summary: weather_Summary
  temperature: weather_Temperature
  timestamp: Int
  wind: weather_Wind
  _join: Query!
}

type weather_Wind {
  deg: Int
  speed: Float
  _join: Query!
}

enum COMMON_REGEX_PATTERN {
  EMAIL
  DOMAIN
}

enum WG_ROLE {
  admin
  user
}

"""Well known claims - https://www.iana.org/assignments/jwt/jwt.xhtml"""
enum WG_CLAIM {
  """iss"""
  ISSUER
  """deprecated alias for ISSUER"""
  PROVIDER
  """sub"""
  SUBJECT
  """alias for sub"""
  USERID
  """name"""
  NAME
  """given_name"""
  GIVEN_NAME
  """family_name"""
  FAMILY_NAME
  """middle_name"""
  MIDDLE_NAME
  """nickname"""
  NICKNAME
  """preferred_username"""
  PREFERRED_USERNAME
  """profile"""
  PROFILE
  """picture"""
  PICTURE
  """website"""
  WEBSITE
  """email"""
  EMAIL
  """email_verified"""
  EMAIL_VERIFIED
  """gender"""
  GENDER
  """birthdate"""
  BIRTH_DATE
  """zoneinfo"""
  ZONE_INFO
  """locale"""
  LOCALE
  """location"""
  LOCATION
}

enum WunderGraphDateTimeFormat {
  "2006-01-02T15:04:05-0700"
  ISO8601
  "Mon Jan _2 15:04:05 2006"
  ANSIC
  "Mon Jan _2 15:04:05 MST 2006"
  UnixDate
  "Mon Jan 02 15:04:05 -0700 2006"
  RubyDate
  "02 Jan 06 15:04 MST"
  RFC822
  "02 Jan 06 15:04 -0700"
  RFC822Z
  "Monday, 02-Jan-06 15:04:05 MST"
  RFC850
  "Mon, 02 Jan 2006 15:04:05 MST"
  RFC1123
  "Mon, 02 Jan 2006 15:04:05 -0700"
  RFC1123Z
  "2006-01-02T15:04:05Z07:00"
  RFC3339
  "2006-01-02T15:04:05.999999999Z07:00"
  RFC3339Nano
  "3:04PM"
  Kitchen
  "Jan _2 15:04:05"
  Stamp
  "Jan _2 15:04:05.000"
  StampMilli
  "Jan _2 15:04:05.000000"
  StampMicro
  "Jan _2 15:04:05.000000000"
  StampNano
}